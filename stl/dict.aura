// stl/dict.aura — Dictionary methods for Aura.
//
// Provides method syntax on Dict type: d.len(), d.keys(), d.has(k), etc.
//
// Kernel primitives bound via builtin():
//   dict_keys, dict_values, dict_entries, dict_has, dict_delete,
//   dict_len, dict_merge

// ─────────────────────────────────────────────────────────────────────────────
// Kernel bindings
// ─────────────────────────────────────────────────────────────────────────────

def _dict_len = builtin("dict_len");
def _dict_has = builtin("dict_has");
def _dict_delete = builtin("dict_delete");
def _dict_keys = builtin("dict_keys");
def _dict_values = builtin("dict_values");
def _dict_entries = builtin("dict_entries");
def _dict_merge = builtin("dict_merge");

def _list_len = builtin("list_len");

// ─────────────────────────────────────────────────────────────────────────────
// Inspection
// ─────────────────────────────────────────────────────────────────────────────

defn Dict.len(self) -> Int { _dict_len(self) }

defn Dict.isEmpty(self) -> Bool { _dict_len(self) == 0 }

defn Dict.has(self, key: String) -> Bool { _dict_has(self, key) }

defn Dict.keys(self) -> List { _dict_keys(self) }

defn Dict.values(self) -> List { _dict_values(self) }

defn Dict.entries(self) -> List { _dict_entries(self) }

// ─────────────────────────────────────────────────────────────────────────────
// Access
// ─────────────────────────────────────────────────────────────────────────────

defn Dict.get(self, key: String) -> Value {
    if (_dict_has(self, key)) {
        self[key]
    } else {
        .null
    }
}

defn Dict.getOr(self, key: String, default) -> Value {
    if (_dict_has(self, key)) {
        self[key]
    } else {
        default
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Mutation
// ─────────────────────────────────────────────────────────────────────────────

defn Dict.delete(self, key: String) -> Void { _dict_delete(self, key) }

defn Dict.merge(self, other: Dict) -> Dict { _dict_merge(self, other) }

// ─────────────────────────────────────────────────────────────────────────────
// Higher-order methods
// ─────────────────────────────────────────────────────────────────────────────

defn Dict.each(self, f) -> Void {
    let ks: List = _dict_keys(self);
    let i: Int = 0;
    let n: Int = _list_len(ks);
    loop while { i < n } do {
        f(ks[i], self[ks[i]]);
        i++;
    }
}

defn Dict.mapValues(self, f) -> Dict {
    let result: Dict = [];
    let ks: List = _dict_keys(self);
    let i: Int = 0;
    let n: Int = _list_len(ks);
    loop while { i < n } do {
        let k = ks[i];
        result[k] = f(k, self[k]);
        i++;
    }
    result
}

defn Dict.filter(self, pred) -> Dict {
    let result: Dict = [];
    let ks: List = _dict_keys(self);
    let i: Int = 0;
    let n: Int = _list_len(ks);
    loop while { i < n } do {
        let k = ks[i];
        if (pred(k, self[k])) {
            result[k] = self[k];
        }
        i++;
    }
    result
}

defn Dict.reduce(self, init, f) -> Value {
    let acc = init;
    let ks: List = _dict_keys(self);
    let i: Int = 0;
    let n: Int = _list_len(ks);
    loop while { i < n } do {
        let k = ks[i];
        acc = f(acc, k, self[k]);
        i++;
    }
    acc
}

defn Dict.any(self, pred) -> Bool {
    let ks: List = _dict_keys(self);
    let i: Int = 0;
    let n: Int = _list_len(ks);
    loop while { i < n } do {
        let k = ks[i];
        if (pred(k, self[k])) {
            return true
        }
        i++;
    }
    false
}

defn Dict.all(self, pred) -> Bool {
    let ks: List = _dict_keys(self);
    let i: Int = 0;
    let n: Int = _list_len(ks);
    loop while { i < n } do {
        let k = ks[i];
        if (!pred(k, self[k])) {
            return false
        }
        i++;
    }
    true
}

defn main() {}
