// stl/dict.aura — Dictionary utilities for Aura.
//
// Wraps the native dict primitives and provides higher-order helpers
// built in pure Aura.
//
// Functions that can fail return Option or Result variants:
//   .some(value) | .null       — for lookups that may not find anything
//   .ok(value)   | .error(msg) — for operations that can fail with a reason
//
// Native primitives used:
//   dict_keys, dict_values, dict_entries, dict_has, dict_delete,
//   dict_len, dict_merge, is_null

// ── Inspection ────────────────────────────────────────────────────────────────

// Return the number of key-value pairs in the dict.
pub defn len(d: Dict[String, V]) -> Int {
    dict_len(d)
}

// Return true if the dict contains no entries.
pub defn is_empty(d: Dict[String, V]) -> Bool {
    dict_len(d) == 0
}

// Return true if `key` exists in the dict.
pub defn has(d: Dict[String, V], key: String) -> Bool {
    dict_has(d, key)
}

// Return all keys as a list.
pub defn keys(d: Dict[String, V]) -> List[String] {
    dict_keys(d)
}

// Return all values as a list.
pub defn values(d: Dict[String, V]) -> List[V] {
    dict_values(d)
}

// Return all [key, value] pairs as a list.
pub defn entries(d: Dict[String, V]) -> List[List[T]] {
    dict_entries(d)
}

// ── Access ────────────────────────────────────────────────────────────────────

// Return the value for `key` wrapped in .some, or .null if not found.
pub defn get(d: Dict[String, V], key: String) -> Option[V] {
    if (dict_has(d, key)) {
        .some(d[key])
    } else {
        .null
    }
}

// Return the value for `key`, or `default` if not found.
pub defn get_or(d: Dict[String, V], key: String, default: V) -> V {
    if (dict_has(d, key)) {
        d[key]
    } else {
        default
    }
}

// ── Mutation helpers ──────────────────────────────────────────────────────────

// Delete `key` from the dict.  Returns .ok(Void) if the key existed,
// .error(msg) if it was not present.
pub defn remove(d: Dict[String, V], key: String) -> Result[Void, String] {
    if (dict_has(d, key)) {
        dict_delete(d, key);
        .ok(null)
    } else {
        .error("key \"$(key)\" not found in dict")
    }
}

// Merge `other` into `base`, returning a new dict.  Keys in `other` win on conflict.
pub defn merge(base: Dict[String, V], other: Dict[String, V]) -> Dict[String, V] {
    dict_merge(base, other)
}

// ── Higher-order combinators ─────────────────────────────────────────────────

// Apply `f(key, value)` to every entry for its side effects.
pub defn each(d: Dict[String, V], f: Func[(String, V), Void]) -> Void {
    let ks: List[String] = dict_keys(d);
    let i: Int = 0;
    let n: Int = list_len(ks);
    loop while { i < n } do {
        f(ks[i], d[ks[i]]);
        i++;
    }
}

// Return a new dict with values transformed by `f(key, value) -> W`.
pub defn map_values(d: Dict[String, V], f: Func[(String, V), W]) -> Dict[String, W] {
    let result: Dict[String, W] = [];
    let ks: List[String] = dict_keys(d);
    let i: Int = 0;
    let n: Int = list_len(ks);
    loop while { i < n } do {
        let k: String = ks[i];
        result[k] = f(k, d[k]);
        i++;
    }
    result
}

// Return a new dict containing only entries for which `pred(key, value)` is true.
pub defn filter(d: Dict[String, V], pred: Func[(String, V), Bool]) -> Dict[String, V] {
    let result: Dict[String, V] = [];
    let ks: List[String] = dict_keys(d);
    let i: Int = 0;
    let n: Int = list_len(ks);
    loop while { i < n } do {
        let k: String = ks[i];
        if (pred(k, d[k])) {
            result[k] = d[k];
        }
        i++;
    }
    result
}

// Reduce all entries to a single value by applying `f(acc, key, value)`.
pub defn reduce(d: Dict[String, V], init: A, f: Func[(A, String, V), A]) -> A {
    let acc: A = init;
    let ks: List[String] = dict_keys(d);
    let i: Int = 0;
    let n: Int = list_len(ks);
    loop while { i < n } do {
        let k: String = ks[i];
        acc = f(acc, k, d[k]);
        i++;
    }
    acc
}

// Return true if `pred(key, value)` is true for at least one entry.
pub defn any(d: Dict[String, V], pred: Func[(String, V), Bool]) -> Bool {
    let ks: List[String] = dict_keys(d);
    let i: Int = 0;
    let n: Int = list_len(ks);
    loop while { i < n } do {
        let k: String = ks[i];
        if (pred(k, d[k])) {
            return true
        }
        i++;
    }
    false
}

// Return true if `pred(key, value)` is true for every entry.
pub defn all(d: Dict[String, V], pred: Func[(String, V), Bool]) -> Bool {
    let ks: List[String] = dict_keys(d);
    let i: Int = 0;
    let n: Int = list_len(ks);
    loop while { i < n } do {
        let k: String = ks[i];
        if (!pred(k, d[k])) {
            return false
        }
        i++;
    }
    true
}

// ── Construction ──────────────────────────────────────────────────────────────

// Build a dict from a list of [key, value] pairs.
// Later pairs overwrite earlier ones for duplicate keys.
pub defn from_entries(entries: List[List[T]]) -> Dict[String, T] {
    let result: Dict[String, T] = [];
    let i: Int = 0;
    let n: Int = list_len(entries);
    loop while { i < n } do {
        let pair: List[T] = entries[i];
        result[pair[0]] = pair[1];
        i++;
    }
    result
}

// Build a dict from a list of keys and a list of values (zipped).
// Stops at the shorter list.
pub defn from_lists(keys: List[String], values: List[V]) -> Dict[String, V] {
    let result: Dict[String, V] = [];
    let nk: Int = list_len(keys);
    let nv: Int = list_len(values);
    let n: Int = if (nk < nv) { nk } else { nv };
    let i: Int = 0;
    loop while { i < n } do {
        result[keys[i]] = values[i];
        i++;
    }
    result
}
