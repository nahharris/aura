// stl/list.aura — List methods for Aura.
//
// Provides method syntax on List type: list.len(), list.push(x), etc.
// Higher-order methods (map, filter, reduce) are implemented in pure Aura.
//
// Kernel primitives bound via builtin():
//   list_len, list_push, list_pop, list_insert, list_remove, list_contains,
//   list_reverse, list_sort, list_concat, list_slice, list_first, list_last,
//   list_flatten, list_range, list_index_of

// ─────────────────────────────────────────────────────────────────────────────
// Kernel bindings
// ─────────────────────────────────────────────────────────────────────────────

def _list_len = builtin("list_len");
def _list_push = builtin("list_push");
def _list_pop = builtin("list_pop");
def _list_insert = builtin("list_insert");
def _list_remove = builtin("list_remove");
def _list_contains = builtin("list_contains");
def _list_reverse = builtin("list_reverse");
def _list_sort = builtin("list_sort");
def _list_concat = builtin("list_concat");
def _list_slice = builtin("list_slice");
def _list_first = builtin("list_first");
def _list_last = builtin("list_last");
def _list_flatten = builtin("list_flatten");
def _list_range = builtin("list_range");
def _list_index_of = builtin("list_index_of");

// ─────────────────────────────────────────────────────────────────────────────
// Inspection
// ─────────────────────────────────────────────────────────────────────────────

defn List.len(self) -> Int { _list_len(self) }

defn List.isEmpty(self) -> Bool { _list_len(self) == 0 }

defn List.contains(self, value) -> Bool { _list_contains(self, value) }

defn List.indexOf(self, value) -> Int { _list_index_of(self, value) }

defn List.first(self) -> Value { _list_first(self) }

defn List.last(self) -> Value { _list_last(self) }

defn List.get(self, i: Int) -> Value {
    let n: Int = _list_len(self);
    let actual: Int = if (i < 0) { n + i } else { i };
    if (actual < 0 || actual >= n) {
        .null
    } else {
        self[actual]
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Mutation
// ─────────────────────────────────────────────────────────────────────────────

defn List.push(self, item) -> Void { _list_push(self, item) }

defn List.pop(self) -> Value { _list_pop(self) }

defn List.insert(self, index: Int, item) -> Void { _list_insert(self, index, item) }

defn List.remove(self, index: Int) -> Value { _list_remove(self, index) }

// ─────────────────────────────────────────────────────────────────────────────
// Slicing
// ─────────────────────────────────────────────────────────────────────────────

defn List.slice(self, start: Int, end: Int) -> List { _list_slice(self, start, end) }

defn List.take(self, n: Int) -> List {
    let slen: Int = _list_len(self);
    let end: Int = if (n > slen) { slen } else { if (n < 0) { 0 } else { n } };
    _list_slice(self, 0, end)
}

defn List.drop(self, n: Int) -> List {
    let slen: Int = _list_len(self);
    let start: Int = if (n > slen) { slen } else { if (n < 0) { 0 } else { n } };
    _list_slice(self, start, slen)
}

// ─────────────────────────────────────────────────────────────────────────────
// Transformation
// ─────────────────────────────────────────────────────────────────────────────

defn List.reverse(self) -> List { _list_reverse(self) }

defn List.sort(self) -> List { _list_sort(self) }

defn List.concat(self, other: List) -> List { _list_concat(self, other) }

defn List.flatten(self) -> List { _list_flatten(self) }

// ─────────────────────────────────────────────────────────────────────────────
// Higher-order methods
// ─────────────────────────────────────────────────────────────────────────────

defn List.map(self, f) -> List {
    let result: List = [];
    let i: Int = 0;
    let n: Int = _list_len(self);
    loop while { i < n } do {
        _list_push(result, f(self[i]));
        i++;
    }
    result
}

defn List.filter(self, pred) -> List {
    let result: List = [];
    let i: Int = 0;
    let n: Int = _list_len(self);
    loop while { i < n } do {
        if (pred(self[i])) {
            _list_push(result, self[i]);
        }
        i++;
    }
    result
}

defn List.reduce(self, init, f) -> Value {
    let acc = init;
    let i: Int = 0;
    let n: Int = _list_len(self);
    loop while { i < n } do {
        acc = f(acc, self[i]);
        i++;
    }
    acc
}

defn List.find(self, pred) -> Value {
    let i: Int = 0;
    let n: Int = _list_len(self);
    loop while { i < n } do {
        if (pred(self[i])) {
            return self[i]
        }
        i++;
    }
    .null
}

defn List.any(self, pred) -> Bool {
    let i: Int = 0;
    let n: Int = _list_len(self);
    loop while { i < n } do {
        if (pred(self[i])) {
            return true
        }
        i++;
    }
    false
}

defn List.all(self, pred) -> Bool {
    let i: Int = 0;
    let n: Int = _list_len(self);
    loop while { i < n } do {
        if (!pred(self[i])) {
            return false
        }
        i++;
    }
    true
}

defn List.each(self, f) -> Void {
    let i: Int = 0;
    let n: Int = _list_len(self);
    loop while { i < n } do {
        f(self[i]);
        i++;
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Aggregates
// ─────────────────────────────────────────────────────────────────────────────

defn List.sum(self) -> Int {
    let acc: Int = 0;
    let i: Int = 0;
    let n: Int = _list_len(self);
    loop while { i < n } do {
        acc = acc + self[i];
        i++;
    }
    acc
}

defn List.product(self) -> Int {
    let acc: Int = 1;
    let i: Int = 0;
    let n: Int = _list_len(self);
    loop while { i < n } do {
        acc = acc * self[i];
        i++;
    }
    acc
}

defn List.min(self) -> Value {
    let n: Int = _list_len(self);
    if (n == 0) {
        return .null
    }
    let m = self[0];
    let i: Int = 1;
    loop while { i < n } do {
        if (self[i] < m) {
            m = self[i];
        }
        i++;
    }
    m
}

defn List.max(self) -> Value {
    let n: Int = _list_len(self);
    if (n == 0) {
        return .null
    }
    let m = self[0];
    let i: Int = 1;
    loop while { i < n } do {
        if (self[i] > m) {
            m = self[i];
        }
        i++;
    }
    m
}

defn main() {}
