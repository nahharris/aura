// stl/list.aura — List utilities for Aura.
//
// Wraps the native list primitives and provides higher-order combinators
// (map, filter, reduce, etc.) built in pure Aura.
//
// Functions that can fail return Option or Result variants:
//   .some(value) | .null       — for lookups that may not find anything
//   .ok(value)   | .error(msg) — for operations that can fail with a reason
//
// Native primitives used:
//   list_len, list_push, list_pop, list_insert, list_remove, list_contains,
//   list_reverse, list_sort, list_concat, list_slice, list_first, list_last,
//   list_flatten, list_range, list_index_of, is_null

// ── Inspection ────────────────────────────────────────────────────────────────

// Return the number of elements in the list.
pub defn len(lst: List[T]) -> Int {
    list_len(lst)
}

// Return true if the list has zero elements.
pub defn is_empty(lst: List[T]) -> Bool {
    list_len(lst) == 0
}

// Return true if `value` is in the list (uses == equality).
pub defn contains(lst: List[T], value: T) -> Bool {
    list_contains(lst, value)
}

// Return the index of the first occurrence of `value`, or .null if not found.
pub defn index_of(lst: List[T], value: T) -> Option[Int] {
    let idx: Int = list_index_of(lst, value);
    if (is_null(idx)) {
        .null
    } else {
        .some(idx)
    }
}

// Return the first element wrapped in .some, or .null if the list is empty.
pub defn first(lst: List[T]) -> Option[T] {
    let v: T = list_first(lst);
    if (is_null(v)) {
        .null
    } else {
        .some(v)
    }
}

// Return the last element wrapped in .some, or .null if the list is empty.
pub defn last(lst: List[T]) -> Option[T] {
    let v: T = list_last(lst);
    if (is_null(v)) {
        .null
    } else {
        .some(v)
    }
}

// Return the element at index `i` wrapped in .some, or .null if out of bounds.
// Negative indices count from the end: get(lst, -1) returns the last element.
pub defn get(lst: List[T], i: Int) -> Option[T] {
    let n: Int = list_len(lst);
    let actual: Int = if (i < 0) { n + i } else { i };
    if (actual < 0 || actual >= n) {
        .null
    } else {
        .some(lst[actual])
    }
}

// ── Slicing ───────────────────────────────────────────────────────────────────

// Return a slice of `lst` from `start` (inclusive) to `end` (exclusive).
// Returns .ok(slice) or .error(msg) on invalid bounds.
pub defn slice(lst: List[T], start: Int, end: Int) -> Result[List[T], String] {
    let n: Int = list_len(lst);
    if (start < 0 || end < start || end > n) {
        .error("slice bounds $(start)..$(end) out of range for list of length $(n)")
    } else {
        .ok(list_slice(lst, start, end))
    }
}

// Return the first `n` elements of `lst`.
pub defn take(lst: List[T], n: Int) -> List[T] {
    let slen: Int = list_len(lst);
    let end: Int = if (n > slen) { slen } else { if (n < 0) { 0 } else { n } };
    list_slice(lst, 0, end)
}

// Return `lst` with the first `n` elements removed.
pub defn drop(lst: List[T], n: Int) -> List[T] {
    let slen: Int = list_len(lst);
    let start: Int = if (n > slen) { slen } else { if (n < 0) { 0 } else { n } };
    list_slice(lst, start, slen)
}

// ── Construction ──────────────────────────────────────────────────────────────

// Return a list of integers from `start` (inclusive) to `end` (exclusive).
pub defn range(start: Int, end: Int) -> List[Int] {
    list_range(start, end)
}

// Return a list of `n` copies of `value`.
pub defn repeat(value: T, n: Int) -> List[T] {
    let result: List[T] = [];
    let i: Int = 0;
    loop while { i < n } do {
        list_push(result, value);
        i++;
    }
    result
}

// Zip two lists into a list of [a, b] pairs (stops at the shorter list).
pub defn zip(a: List[A], b: List[B]) -> List[List[T]] {
    let na: Int = list_len(a);
    let nb: Int = list_len(b);
    let n: Int = if (na < nb) { na } else { nb };
    let result: List[List[T]] = [];
    let i: Int = 0;
    loop while { i < n } do {
        list_push(result, [a[i], b[i]]);
        i++;
    }
    result
}

// Return a list of [index, value] pairs for each element.
pub defn enumerate(lst: List[T]) -> List[List[T]] {
    let result: List[List[T]] = [];
    let i: Int = 0;
    let n: Int = list_len(lst);
    loop while { i < n } do {
        list_push(result, [i, lst[i]]);
        i++;
    }
    result
}

// ── Set-like operations ───────────────────────────────────────────────────────

// Return a new list with duplicate values removed (first occurrence kept).
pub defn unique(lst: List[T]) -> List[T] {
    let result: List[T] = [];
    let i: Int = 0;
    let n: Int = list_len(lst);
    loop while { i < n } do {
        let v: T = lst[i];
        if (!list_contains(result, v)) {
            list_push(result, v);
        }
        i++;
    }
    result
}

// Return a new list containing only elements present in both `a` and `b`.
pub defn intersect(a: List[T], b: List[T]) -> List[T] {
    let result: List[T] = [];
    let i: Int = 0;
    let n: Int = list_len(a);
    loop while { i < n } do {
        let v: T = a[i];
        if (list_contains(b, v) && !list_contains(result, v)) {
            list_push(result, v);
        }
        i++;
    }
    result
}

// Return a new list of elements in `a` that are not in `b`.
pub defn difference(a: List[T], b: List[T]) -> List[T] {
    let result: List[T] = [];
    let i: Int = 0;
    let n: Int = list_len(a);
    loop while { i < n } do {
        let v: T = a[i];
        if (!list_contains(b, v)) {
            list_push(result, v);
        }
        i++;
    }
    result
}

// ── Higher-order combinators ─────────────────────────────────────────────────

// Apply `f` to each element and return a new list of the results.
pub defn map(lst: List[A], f: Func[A, B]) -> List[B] {
    let result: List[B] = [];
    let i: Int = 0;
    let n: Int = list_len(lst);
    loop while { i < n } do {
        list_push(result, f(lst[i]));
        i++;
    }
    result
}

// Return a new list containing only elements for which `pred` returns true.
pub defn filter(lst: List[T], pred: Func[T, Bool]) -> List[T] {
    let result: List[T] = [];
    let i: Int = 0;
    let n: Int = list_len(lst);
    loop while { i < n } do {
        if (pred(lst[i])) {
            list_push(result, lst[i]);
        }
        i++;
    }
    result
}

// Reduce the list to a single value by applying `f(acc, element)` left-to-right.
// `init` is the initial accumulator.
pub defn reduce(lst: List[T], init: A, f: Func[(A, T), A]) -> A {
    let acc: A = init;
    let i: Int = 0;
    let n: Int = list_len(lst);
    loop while { i < n } do {
        acc = f(acc, lst[i]);
        i++;
    }
    acc
}

// Return the first element for which `pred` returns true, wrapped in .some,
// or .null if no element matches.
pub defn find(lst: List[T], pred: Func[T, Bool]) -> Option[T] {
    let i: Int = 0;
    let n: Int = list_len(lst);
    loop while { i < n } do {
        if (pred(lst[i])) {
            return .some(lst[i])
        }
        i++;
    }
    .null
}

// Return true if `pred` returns true for at least one element.
pub defn any(lst: List[T], pred: Func[T, Bool]) -> Bool {
    let i: Int = 0;
    let n: Int = list_len(lst);
    loop while { i < n } do {
        if (pred(lst[i])) {
            return true
        }
        i++;
    }
    false
}

// Return true if `pred` returns true for every element.
pub defn all(lst: List[T], pred: Func[T, Bool]) -> Bool {
    let i: Int = 0;
    let n: Int = list_len(lst);
    loop while { i < n } do {
        if (!pred(lst[i])) {
            return false
        }
        i++;
    }
    true
}

// Apply `f` to each element for its side effects; returns Void.
pub defn each(lst: List[T], f: Func[T, Void]) -> Void {
    let i: Int = 0;
    let n: Int = list_len(lst);
    loop while { i < n } do {
        f(lst[i]);
        i++;
    }
}

// Apply `f(index, element)` to each element for its side effects.
pub defn each_with_index(lst: List[T], f: Func[(Int, T), Void]) -> Void {
    let i: Int = 0;
    let n: Int = list_len(lst);
    loop while { i < n } do {
        f(i, lst[i]);
        i++;
    }
}

// ── Aggregates ────────────────────────────────────────────────────────────────

// Return the sum of a list of numbers.
pub defn sum(lst: List[Int]) -> Int {
    let acc: Int = 0;
    let i: Int = 0;
    let n: Int = list_len(lst);
    loop while { i < n } do {
        acc = acc + lst[i];
        i++;
    }
    acc
}

// Return the sum of a list of floats.
pub defn sum_float(lst: List[Float]) -> Float {
    let acc: Float = 0.0;
    let i: Int = 0;
    let n: Int = list_len(lst);
    loop while { i < n } do {
        acc = acc + lst[i];
        i++;
    }
    acc
}

// Return the product of a list of numbers.
pub defn product(lst: List[Int]) -> Int {
    let acc: Int = 1;
    let i: Int = 0;
    let n: Int = list_len(lst);
    loop while { i < n } do {
        acc = acc * lst[i];
        i++;
    }
    acc
}

// Return the minimum value in a list, or .null if the list is empty.
pub defn min(lst: List[T]) -> Option[T] {
    let n: Int = list_len(lst);
    if (n == 0) {
        return .null
    }
    let m: T = lst[0];
    let i: Int = 1;
    loop while { i < n } do {
        if (lst[i] < m) {
            m = lst[i];
        }
        i++;
    }
    .some(m)
}

// Return the maximum value in a list, or .null if the list is empty.
pub defn max(lst: List[T]) -> Option[T] {
    let n: Int = list_len(lst);
    if (n == 0) {
        return .null
    }
    let m: T = lst[0];
    let i: Int = 1;
    loop while { i < n } do {
        if (lst[i] > m) {
            m = lst[i];
        }
        i++;
    }
    .some(m)
}

// ── Reordering ────────────────────────────────────────────────────────────────

// Return a new list with the elements in reverse order.
pub defn reverse(lst: List[T]) -> List[T] {
    list_reverse(lst)
}

// Return a new sorted list (ascending, using natural < ordering).
pub defn sort(lst: List[T]) -> List[T] {
    list_sort(lst)
}

// Concatenate two lists into a new list.
pub defn concat(a: List[T], b: List[T]) -> List[T] {
    list_concat(a, b)
}

// Flatten a list of lists by one level.
pub defn flatten(lst: List[List[T]]) -> List[T] {
    list_flatten(lst)
}

// Map then flatten (flat_map / bind).
pub defn flat_map(lst: List[A], f: Func[A, List[B]]) -> List[B] {
    list_flatten(map(lst, f))
}
