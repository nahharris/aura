// stl/math.aura — Mathematical functions for Aura.
//
// Wraps the native math primitives and adds combinators built in pure Aura.
// Functions that can fail (e.g. sqrt of a negative number) return Result:
//   .ok(value)   | .error(msg)
//
// Native primitives used:
//   math_abs, math_floor, math_ceil, math_round, math_sqrt, math_pow,
//   math_log, math_log2, math_log10, math_sin, math_cos, math_tan,
//   math_asin, math_acos, math_atan, math_atan2, math_min, math_max,
//   math_clamp, math_random, math_pi, math_e, math_inf,
//   math_is_nan, math_is_inf, math_trunc, math_fract, math_sign

// ── Constants ────────────────────────────────────────────────────────────────

// The mathematical constant π (pi ≈ 3.14159…).
pub def PI = math_pi()

// Euler's number e ≈ 2.71828…
pub def E = math_e()

// Positive infinity.
pub def INF = math_inf()

// ── Rounding ─────────────────────────────────────────────────────────────────

// Return the absolute value of `x`.
pub defn abs(x: Float) -> Float {
    math_abs(x)
}

// Return the largest integer <= `x`.
pub defn floor(x: Float) -> Float {
    math_floor(x)
}

// Return the smallest integer >= `x`.
pub defn ceil(x: Float) -> Float {
    math_ceil(x)
}

// Return `x` rounded to the nearest integer (half rounds up).
pub defn round(x: Float) -> Float {
    math_round(x)
}

// Return the integer part of `x` (truncate toward zero).
pub defn trunc(x: Float) -> Float {
    math_trunc(x)
}

// Return the fractional part of `x` (x - trunc(x)).
pub defn fract(x: Float) -> Float {
    math_fract(x)
}

// ── Sign and classification ────────────────────────────────────────────────────

// Return -1.0, 0.0, or 1.0 depending on the sign of `x`.
pub defn sign(x: Float) -> Float {
    math_sign(x)
}

// Return true if `x` is IEEE NaN.
pub defn is_nan(x: Float) -> Bool {
    math_is_nan(x)
}

// Return true if `x` is positive or negative infinity.
pub defn is_inf(x: Float) -> Bool {
    math_is_inf(x)
}

// Return true if `x` is a finite, non-NaN value.
pub defn is_finite(x: Float) -> Bool {
    !math_is_nan(x) && !math_is_inf(x)
}

// ── Powers and roots ──────────────────────────────────────────────────────────

// Return `base` raised to the power `exp`.
pub defn pow(base: Float, exp: Float) -> Float {
    math_pow(base, exp)
}

// Return the square root of `x`.
// Returns .ok(result) on success, .error(msg) if x < 0.
pub defn sqrt(x: Float) -> Result[Float, String] {
    if (x < 0.0) {
        .error("sqrt of negative number: $(x)")
    } else {
        .ok(math_sqrt(x))
    }
}

// Return the square root of `x`, panicking if x < 0.
// Use sqrt() for a safe version.
pub defn sqrt_unsafe(x: Float) -> Float {
    math_sqrt(x)
}

// ── Logarithms ───────────────────────────────────────────────────────────────

// Return the natural logarithm (base e) of `x`.
// Returns .ok(result) on success, .error(msg) if x <= 0.
pub defn ln(x: Float) -> Result[Float, String] {
    if (x <= 0.0) {
        .error("ln of non-positive number: $(x)")
    } else {
        .ok(math_log(x))
    }
}

// Return the base-2 logarithm of `x`.
// Returns .ok(result) on success, .error(msg) if x <= 0.
pub defn log2(x: Float) -> Result[Float, String] {
    if (x <= 0.0) {
        .error("log2 of non-positive number: $(x)")
    } else {
        .ok(math_log2(x))
    }
}

// Return the base-10 logarithm of `x`.
// Returns .ok(result) on success, .error(msg) if x <= 0.
pub defn log10(x: Float) -> Result[Float, String] {
    if (x <= 0.0) {
        .error("log10 of non-positive number: $(x)")
    } else {
        .ok(math_log10(x))
    }
}

// Return the logarithm of `x` in the given `base`.
// Returns .ok(result) on success, .error(msg) if x <= 0 or base <= 0 or base == 1.
pub defn log(x: Float, base: Float) -> Result[Float, String] {
    if (x <= 0.0) {
        .error("log of non-positive number: $(x)")
    } else if (base <= 0.0 || base == 1.0) {
        .error("invalid logarithm base: $(base)")
    } else {
        .ok(math_log(x) / math_log(base))
    }
}

// ── Trigonometry ─────────────────────────────────────────────────────────────

// Return the sine of `x` (x in radians).
pub defn sin(x: Float) -> Float {
    math_sin(x)
}

// Return the cosine of `x` (x in radians).
pub defn cos(x: Float) -> Float {
    math_cos(x)
}

// Return the tangent of `x` (x in radians).
pub defn tan(x: Float) -> Float {
    math_tan(x)
}

// Return the arcsine of `x` in radians.
// Returns .ok(result) on success, .error(msg) if x is outside [-1, 1].
pub defn asin(x: Float) -> Result[Float, String] {
    if (x < -1.0 || x > 1.0) {
        .error("asin argument out of range [-1, 1]: $(x)")
    } else {
        .ok(math_asin(x))
    }
}

// Return the arccosine of `x` in radians.
// Returns .ok(result) on success, .error(msg) if x is outside [-1, 1].
pub defn acos(x: Float) -> Result[Float, String] {
    if (x < -1.0 || x > 1.0) {
        .error("acos argument out of range [-1, 1]: $(x)")
    } else {
        .ok(math_acos(x))
    }
}

// Return the arctangent of `x` in radians.
pub defn atan(x: Float) -> Float {
    math_atan(x)
}

// Return the four-quadrant arctangent of (y, x) in radians.
pub defn atan2(y: Float, x: Float) -> Float {
    math_atan2(y, x)
}

// Convert degrees to radians.
pub defn to_radians(degrees: Float) -> Float {
    degrees * math_pi() / 180.0
}

// Convert radians to degrees.
pub defn to_degrees(radians: Float) -> Float {
    radians * 180.0 / math_pi()
}

// ── Extrema and clamping ──────────────────────────────────────────────────────

// Return the smaller of two values.
pub defn min(a: Float, b: Float) -> Float {
    math_min(a, b)
}

// Return the larger of two values.
pub defn max(a: Float, b: Float) -> Float {
    math_max(a, b)
}

// Clamp `x` to the closed interval [lo, hi].
pub defn clamp(x: Float, lo: Float, hi: Float) -> Float {
    math_clamp(x, lo, hi)
}

// ── Interpolation ────────────────────────────────────────────────────────────

// Linear interpolation between `a` and `b` by factor `t` in [0, 1].
pub defn lerp(a: Float, b: Float, t: Float) -> Float {
    a + (b - a) * t
}

// Inverse of lerp: return the t in [0, 1] that maps to `v` between `a` and `b`.
// Returns .ok(t) on success, .error(msg) if a == b (degenerate range).
pub defn inv_lerp(a: Float, b: Float, v: Float) -> Result[Float, String] {
    if (a == b) {
        .error("inv_lerp: a and b are equal ($(a)), degenerate range")
    } else {
        .ok((v - a) / (b - a))
    }
}

// ── Number theory ─────────────────────────────────────────────────────────────

// Return the greatest common divisor of two non-negative integers.
pub defn gcd(a: Int, b: Int) -> Int {
    let x: Int = if (a < 0) { -a } else { a };
    let y: Int = if (b < 0) { -b } else { b };
    loop while { y != 0 } do {
        let tmp: Int = y;
        y = x % y;
        x = tmp;
    }
    x
}

// Return the least common multiple of two non-negative integers.
// Returns .ok(result) on success, .error(msg) if both are zero.
pub defn lcm(a: Int, b: Int) -> Result[Int, String] {
    if (a == 0 && b == 0) {
        .error("lcm(0, 0) is undefined")
    } else {
        let g: Int = gcd(a, b);
        .ok((a / g) * b)
    }
}

// Return true if `n` is even.
pub defn is_even(n: Int) -> Bool {
    n % 2 == 0
}

// Return true if `n` is odd.
pub defn is_odd(n: Int) -> Bool {
    n % 2 != 0
}

// ── Random ────────────────────────────────────────────────────────────────────

// Return a uniformly distributed random Float in [0.0, 1.0).
pub defn random() -> Float {
    math_random()
}

// Return a uniformly distributed random Float in [lo, hi).
pub defn random_range(lo: Float, hi: Float) -> Float {
    lo + math_random() * (hi - lo)
}

// Return a uniformly distributed random Int in [lo, hi) (exclusive upper bound).
pub defn random_int(lo: Int, hi: Int) -> Int {
    lo + (math_floor(math_random() * (hi - lo)) : Int)
}
