// stl/math.aura — Mathematical functions for Aura.
//
// Provides constants and mathematical functions.
// Functions that can fail return Result:
//   .ok(value)   | .error(msg)
//
// Kernel primitives bound via builtin():
//   math_abs, math_floor, math_ceil, math_round, math_sqrt, math_pow,
//   math_log, math_log2, math_log10, math_sin, math_cos, math_tan,
//   math_asin, math_acos, math_atan, math_atan2, math_min, math_max,
//   math_clamp, math_random, math_pi, math_e, math_inf,
//   math_is_nan, math_is_inf, math_trunc, math_fract, math_sign

// ─────────────────────────────────────────────────────────────────────────────
// Kernel bindings
// ─────────────────────────────────────────────────────────────────────────────

def _math_abs = builtin("math_abs");
def _math_floor = builtin("math_floor");
def _math_ceil = builtin("math_ceil");
def _math_round = builtin("math_round");
def _math_sqrt = builtin("math_sqrt");
def _math_pow = builtin("math_pow");
def _math_log = builtin("math_log");
def _math_log2 = builtin("math_log2");
def _math_log10 = builtin("math_log10");
def _math_sin = builtin("math_sin");
def _math_cos = builtin("math_cos");
def _math_tan = builtin("math_tan");
def _math_asin = builtin("math_asin");
def _math_acos = builtin("math_acos");
def _math_atan = builtin("math_atan");
def _math_atan2 = builtin("math_atan2");
def _math_min = builtin("math_min");
def _math_max = builtin("math_max");
def _math_clamp = builtin("math_clamp");
def _math_random = builtin("math_random");
def _math_pi = builtin("math_pi");
def _math_e = builtin("math_e");
def _math_inf = builtin("math_inf");
def _math_is_nan = builtin("math_is_nan");
def _math_is_inf = builtin("math_is_inf");
def _math_trunc = builtin("math_trunc");
def _math_fract = builtin("math_fract");
def _math_sign = builtin("math_sign");

// ─────────────────────────────────────────────────────────────────────────────
// Constants
// ─────────────────────────────────────────────────────────────────────────────

def PI = _math_pi()
def E = _math_e()
def INF = _math_inf()

// ─────────────────────────────────────────────────────────────────────────────
// Rounding
// ─────────────────────────────────────────────────────────────────────────────

pub defn abs(x: Float) -> Float { _math_abs(x) }
pub defn floor(x: Float) -> Float { _math_floor(x) }
pub defn ceil(x: Float) -> Float { _math_ceil(x) }
pub defn round(x: Float) -> Float { _math_round(x) }
pub defn trunc(x: Float) -> Float { _math_trunc(x) }
pub defn fract(x: Float) -> Float { _math_fract(x) }

// ─────────────────────────────────────────────────────────────────────────────
// Sign and classification
// ─────────────────────────────────────────────────────────────────────────────

pub defn sign(x: Float) -> Float { _math_sign(x) }
pub defn isNaN(x: Float) -> Bool { _math_is_nan(x) }
pub defn isInf(x: Float) -> Bool { _math_is_inf(x) }
pub defn isFinite(x: Float) -> Bool { !_math_is_nan(x) && !_math_is_inf(x) }

// ─────────────────────────────────────────────────────────────────────────────
// Powers and roots
// ─────────────────────────────────────────────────────────────────────────────

pub defn pow(base: Float, exp: Float) -> Float { _math_pow(base, exp) }
pub defn sqrt(x: Float) -> Float { _math_sqrt(x) }

// ─────────────────────────────────────────────────────────────────────────────
// Logarithms
// ─────────────────────────────────────────────────────────────────────────────

pub defn ln(x: Float) -> Float { _math_log(x) }
pub defn log2(x: Float) -> Float { _math_log2(x) }
pub defn log10(x: Float) -> Float { _math_log10(x) }
pub defn log(x: Float, base: Float) -> Float { _math_log(x) / _math_log(base) }

// ─────────────────────────────────────────────────────────────────────────────
// Trigonometry
// ─────────────────────────────────────────────────────────────────────────────

pub defn sin(x: Float) -> Float { _math_sin(x) }
pub defn cos(x: Float) -> Float { _math_cos(x) }
pub defn tan(x: Float) -> Float { _math_tan(x) }
pub defn asin(x: Float) -> Float { _math_asin(x) }
pub defn acos(x: Float) -> Float { _math_acos(x) }
pub defn atan(x: Float) -> Float { _math_atan(x) }
pub defn atan2(y: Float, x: Float) -> Float { _math_atan2(y, x) }

pub defn toRadians(degrees: Float) -> Float { degrees * _math_pi() / 180.0 }
pub defn toDegrees(radians: Float) -> Float { radians * 180.0 / _math_pi() }

// ─────────────────────────────────────────────────────────────────────────────
// Extrema and clamping
// ─────────────────────────────────────────────────────────────────────────────

pub defn min(a: Float, b: Float) -> Float { _math_min(a, b) }
pub defn max(a: Float, b: Float) -> Float { _math_max(a, b) }
pub defn clamp(x: Float, lo: Float, hi: Float) -> Float { _math_clamp(x, lo, hi) }

// ─────────────────────────────────────────────────────────────────────────────
// Interpolation
// ─────────────────────────────────────────────────────────────────────────────

pub defn lerp(a: Float, b: Float, t: Float) -> Float { a + (b - a) * t }

// ─────────────────────────────────────────────────────────────────────────────
// Number theory
// ─────────────────────────────────────────────────────────────────────────────

pub defn gcd(a: Int, b: Int) -> Int {
    let x: Int = if (a < 0) { -a } else { a };
    let y: Int = if (b < 0) { -b } else { b };
    loop while { y != 0 } do {
        let tmp: Int = y;
        y = x % y;
        x = tmp;
    }
    x
}

pub defn lcm(a: Int, b: Int) -> Int {
    let g: Int = gcd(a, b);
    (a / g) * b
}

pub defn isEven(n: Int) -> Bool { n % 2 == 0 }
pub defn isOdd(n: Int) -> Bool { n % 2 != 0 }

// ─────────────────────────────────────────────────────────────────────────────
// Random
// ─────────────────────────────────────────────────────────────────────────────

pub defn random() -> Float { _math_random() }

pub defn randomRange(lo: Float, hi: Float) -> Float { lo + _math_random() * (hi - lo) }

pub defn randomInt(lo: Int, hi: Int) -> Int { lo + (_math_floor(_math_random() * (hi - lo)) : Int) }

defn main() {}
